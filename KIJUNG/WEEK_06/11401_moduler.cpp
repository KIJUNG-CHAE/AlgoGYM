// 이 문제는 동적계획법으론 절대 안된다. 왜냐하면 4백만 * 4백만 * 16B 면 ㅋㅋ 256메가 바이트로는 택도 없다.
// 그래서 생각해낸게 11401_2같은 방법인데, 시간초과가 걸린다. 저장하고 말고를 떠나서 시간복잡도가 엄청나다.
// nCk = n-1Ck + n-1Ck-1 방법으론 안되고 모듈러 연산을 해야한다는 의미다. 
// 나는 분수 모듈러 계산하는 법을 몰랐다.. (나눗셈에 대한 모듈러 연산)

// 나머지 연산의 분배 법칙 (복기)
// (A * B)%P = ((A%P) * (B*P))%P
// (A + B)%P = ((A%P) + (B%P))%P

// 페르마의 소정리를 이용한 분수 나머지 연산
// 분모, 분자에 각 모듈러 연산하면 안된다. 
// 다른 방법을 사용해야하는데,
// p가 소수이고 a와 p가 서로소일 때, a^(p-1) 과 1의 모듈러연산은 같다. 

// a를 B라고 하고 바꿔쓰면
// B^(p-1) = 1 (mod p) 
// B^(p-2) = B^(-1) (mod p) 이다.

// A/B = A*B^(p-2) (mod p)가 성립한다. 
// 이제 문제에 적용해보면

// nCk = n*(n-1)* ... *(n-k+2)*(n-k+1) / k!
// A = n*(n-1)* ... *(n-k+2)*(n-k+1)
// B = k!
// 이므로 A*B^(p-2) (mod p) 식을 분배법칙을 이용해서 풀어주면 nCk (mod p)와 나머지가 같게 나온다!!!
